{"version":3,"file":"physicsapp.cjs.production.min.js","sources":["../src/main/worker/app/appContext.ts","../src/main/worker/shared/types.ts","../src/main/hooks/useWorkerMessages.ts","../src/main/worker/planckjs/collisions/collisions.ts","../src/main/worker/planckjs/bodies.ts","../src/main/worker/app/WorldState.tsx","../src/main/worker/app/Bodies.tsx","../src/main/worker/app/World.tsx","../src/main/worker/app/Collisions.tsx","../src/main/worker/app/buffers.ts","../src/main/worker/app/index.tsx","../src/main/worker/app/logicWorker.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { World } from 'planck-js';\nimport { Subscribe } from '../../hooks/useWorkerMessages';\nimport { Buffers } from '../shared/types';\n\nexport type AppContextState = {\n  updateRate: number;\n  world: World;\n  worker: Worker;\n  logicWorker?: Worker | MessagePort;\n  subscribe: Subscribe;\n  logicSubscribe: Subscribe;\n  buffers: Buffers;\n  logicBuffers: Buffers;\n};\n\nexport const AppContext = createContext((null as unknown) as AppContextState);\n\nexport const useWorld = (): World => {\n  return useContext(AppContext).world;\n};\n\nexport const useAppContext = (): AppContextState => {\n  return useContext(AppContext);\n};\n","import { WorldDef } from 'planck-js';\n\nexport enum WorkerMessageType {\n  INIT,\n  STEP,\n  LOGIC_FRAME,\n  ADD_BODY,\n  REMOVE_BODY,\n  SET_BODY,\n  UPDATE_BODY,\n  PHYSICS_STEP_PROCESSED,\n}\n\nexport enum WorkerOwnerMessageType {\n  FRAME,\n  PHYSICS_STEP,\n  SYNC_BODIES,\n  BEGIN_COLLISION,\n  END_COLLISION,\n  MESSAGE,\n  INITIATED,\n}\n\nexport type Buffers = {\n  positions: Float32Array;\n  angles: Float32Array;\n};\n\nexport type ValidUUID = string | number;\n\nexport type PhysicsProps = {\n  config?: {\n    maxNumberOfDynamicObjects?: number;\n    updateRate?: number;\n  };\n  worldParams?: WorldDef;\n};\n","import { useCallback, useEffect, useRef } from 'react';\n\nexport type Subscribe = (callback: (event: MessageEvent) => void) => () => void;\n\nexport const useWorkerMessages = (worker: undefined | Worker | MessagePort) => {\n  const idCount = useRef(0);\n  const subscriptionsRef = useRef<{\n    [key: string]: (event: MessageEvent) => void;\n  }>({});\n\n  const subscribe = useCallback(\n    (callback: (event: MessageEvent) => void) => {\n      const id = idCount.current;\n      idCount.current += 1;\n\n      subscriptionsRef.current[id] = callback;\n\n      return () => {\n        delete subscriptionsRef.current[id];\n      };\n    },\n    [subscriptionsRef]\n  );\n\n  useEffect(() => {\n    if (!worker) return;\n    const previousOnMessage = worker.onmessage;\n    worker.onmessage = (event: MessageEvent) => {\n      Object.values(subscriptionsRef.current).forEach(callback => {\n        callback(event);\n      });\n      if (previousOnMessage) {\n        (previousOnMessage as any)(event);\n      }\n    };\n  }, [worker, subscriptionsRef]);\n\n  return subscribe;\n};\n","import { Fixture } from 'planck-js';\nimport { FixtureUserData } from './types';\nimport { activeCollisionListeners } from './data';\nimport {\n  sendCollisionBeginEvent,\n  sendCollisionEndEvent,\n} from '../../functions';\n\nexport const getFixtureData = (fixture: Fixture): FixtureUserData | null => {\n  const userData = fixture.getUserData() as null | FixtureUserData;\n  return userData || null;\n};\n\nexport const getFixtureUuid = (data: FixtureUserData | null): string => {\n  if (data && data['uuid']) {\n    return data.uuid;\n  }\n  return '';\n};\n\nexport const getFixtureIndex = (data: FixtureUserData | null): number => {\n  if (data) {\n    return data.fixtureIndex;\n  }\n  return -1;\n};\n\nexport const handleBeginCollision = (fixtureA: Fixture, fixtureB: Fixture) => {\n  const aData = getFixtureData(fixtureA);\n  const bData = getFixtureData(fixtureB);\n  const aUUID = getFixtureUuid(aData);\n  const bUUID = getFixtureUuid(bData);\n\n  if (aUUID && activeCollisionListeners[aUUID]) {\n    sendCollisionBeginEvent(\n      aUUID,\n      bData,\n      getFixtureIndex(aData),\n      fixtureB.isSensor()\n    );\n  }\n\n  if (bUUID && activeCollisionListeners[bUUID]) {\n    sendCollisionBeginEvent(\n      bUUID,\n      aData,\n      getFixtureIndex(bData),\n      fixtureA.isSensor()\n    );\n  }\n};\n\nexport const handleEndCollision = (fixtureA: Fixture, fixtureB: Fixture) => {\n  const aData = getFixtureData(fixtureA);\n  const bData = getFixtureData(fixtureB);\n  const aUUID = getFixtureUuid(aData);\n  const bUUID = getFixtureUuid(bData);\n\n  if (aUUID && activeCollisionListeners[aUUID]) {\n    sendCollisionEndEvent(\n      aUUID,\n      bData,\n      getFixtureIndex(aData),\n      fixtureB.isSensor()\n    );\n  }\n\n  if (bUUID && activeCollisionListeners[bUUID]) {\n    sendCollisionEndEvent(\n      bUUID,\n      aData,\n      getFixtureIndex(bData),\n      fixtureA.isSensor()\n    );\n  }\n};\n","import {dynamicBodiesUuids, existingBodies, planckWorld} from \"./shared\";\nimport {Shape} from \"planck-js/lib/shape\";\nimport {activeCollisionListeners} from \"./collisions/data\";\nimport {addCachedBody, getCachedBody} from \"./cache\";\nimport type {BodyDef, FixtureOpt, Body, Joint} from \"planck-js\";\nimport {Box, Circle, DistanceJoint, RopeJoint, Vec2} from \"planck-js\";\nimport {ValidUUID} from \"../shared/types\";\nimport {syncBodies} from \"../shared\";\n\nexport enum BodyType {\n    static = 'static',\n    kinematic = 'kinematic',\n    dynamic = 'dynamic'\n}\n\nexport enum BodyShape {\n    box = 'box',\n    circle = 'circle',\n}\n\nexport type FixtureBase = {\n    shape: BodyShape,\n    fixtureOptions?: Partial<FixtureOpt>,\n}\n\nexport type BoxFixture = FixtureBase & {\n    hx: number,\n    hy: number,\n    center?: [number, number],\n}\n\nexport const createBoxFixture = ({\n                                     width = 1,\n                                     height = 1,\n                                     center,\n                                     fixtureOptions = {}\n                                 }: {\n    width?: number,\n    height?: number,\n    center?: [number, number],\n    fixtureOptions?: Partial<FixtureOpt>\n}): BoxFixture => {\n    const fixture: BoxFixture = {\n        shape: BodyShape.box,\n        hx: width,\n        hy: height,\n        fixtureOptions,\n    }\n    if (center) {\n        fixture.center = center\n    }\n    return fixture\n}\n\nexport type CircleFixture = FixtureBase & {\n    radius: number,\n}\n\nexport const createCircleFixture = ({ radius = 1, fixtureOptions = {} }: {\n    radius?: number,\n    fixtureOptions?: Partial<FixtureOpt>\n}): CircleFixture => {\n    return {\n        shape: BodyShape.circle,\n        radius,\n        fixtureOptions,\n    }\n}\n\ntype Fixture = BoxFixture | CircleFixture\n\ntype BasicBodyProps = Partial<BodyDef> & {\n    fixtures?: Fixture[],\n}\n\ntype AddBoxBodyProps = BasicBodyProps & {}\n\ntype AddCircleBodyProps = BasicBodyProps & {}\n\nexport type AddBodyDef = BasicBodyProps | AddBoxBodyProps | AddCircleBodyProps\n\nexport type AddBodyProps = AddBodyDef & {\n    uuid: ValidUUID,\n    listenForCollisions: boolean,\n    cacheKey?: string,\n    attachToRope?: boolean,\n}\n\nexport const addBody = ({uuid, cacheKey, listenForCollisions, fixtures = [], attachToRope = false, ...props}: AddBodyProps) => {\n\n    const existingBody = existingBodies.get(uuid)\n\n    if (existingBody) {\n        return existingBody\n    }\n\n    if (listenForCollisions) {\n        activeCollisionListeners[uuid] = true\n    }\n\n    const bodyDef: BodyDef = {\n        type: BodyType.static,\n        fixedRotation: true,\n        ...props,\n    }\n\n    const {type} = bodyDef\n\n    let body: Body | null = null;\n\n    if (cacheKey) {\n        const cachedBody = getCachedBody(cacheKey)\n        if (cachedBody) {\n\n            if (fixtures && fixtures.length > 0) {\n\n                let bodyFixture = cachedBody.getFixtureList()\n\n                fixtures.forEach((fixture, fixtureIndex) => {\n\n                    let fixtureOptions = fixture.fixtureOptions\n\n                    fixtureOptions = {\n                        userData: {\n                            uuid,\n                            fixtureIndex,\n                            ...fixtureOptions?.userData\n                        },\n                        ...fixtureOptions,\n                    }\n\n                    if (bodyFixture) {\n\n                        if (fixtureOptions) {\n                            bodyFixture.setUserData(fixtureOptions.userData)\n                        }\n\n                        bodyFixture = bodyFixture.getNext()\n                    }\n\n                })\n\n            }\n\n            const {position, angle} = props\n\n            if (position) {\n                cachedBody.setPosition(position)\n            }\n\n            if (angle) {\n                cachedBody.setAngle(angle)\n            }\n\n            cachedBody.setActive(true)\n\n            body = cachedBody\n\n        }\n    }\n\n    if (!body) {\n\n        body = planckWorld.createBody(bodyDef)\n\n        if (fixtures && fixtures.length > 0) {\n\n            fixtures.forEach((fixture, fixtureIndex) => {\n\n                const {shape} = fixture\n\n                let fixtureOptions = fixture.fixtureOptions ?? {}\n\n                fixtureOptions = {\n                    ...fixtureOptions,\n                    userData: {\n                        uuid,\n                        fixtureIndex,\n                        ...fixtureOptions?.userData\n                    },\n                }\n\n                let bodyShape: Shape;\n\n                switch (shape) {\n                    case BodyShape.box:\n                        const {hx, hy, center} = fixture as BoxFixture\n                        bodyShape = Box((hx as number) / 2, (hy as number) / 2, center ? Vec2(center[0], center[1]) : undefined) as unknown as Shape\n                        break;\n                    case BodyShape.circle:\n                        const {radius} = fixture as CircleFixture\n                        bodyShape = Circle((radius as number)) as unknown as Shape\n                        break;\n                    default:\n                        throw new Error(`Unhandled body shape ${shape}`)\n                }\n\n                if (fixtureOptions) {\n                    if (body) {\n                        body.createFixture(bodyShape, fixtureOptions as FixtureOpt)\n                    }\n                } else {\n                    if (body) {\n                        body.createFixture(bodyShape)\n                    }\n                }\n\n                // todo - handle rope properly...\n                if (attachToRope) {\n\n                    const {position, angle} = props\n\n                    const ropeJointDef = {\n                        maxLength: 0.5,\n                        localAnchorA: position,\n                        localAnchorB: position,\n                    };\n\n                    const startingBodyDef: BodyDef = {\n                        type: BodyType.static,\n                        fixedRotation: true,\n                        position,\n                        angle,\n                    }\n\n                    const startingBody = planckWorld.createBody(startingBodyDef)\n\n                    if (body) {\n\n                        const distanceJoint = DistanceJoint({\n                            collideConnected: false,\n                            frequencyHz: 5,\n                            dampingRatio: 0.5,\n                            length: 0.15,\n                        }, startingBody, body, position ?? Vec2(0, 0), position ?? Vec2(0, 0))\n\n                        const rope2 = planckWorld.createJoint(RopeJoint(ropeJointDef, startingBody, body, position ?? Vec2(0, 0)) as unknown as Joint);\n                        const rope = planckWorld.createJoint(distanceJoint as unknown as Joint);\n                    }\n\n\n                }\n\n            })\n\n\n        }\n\n    }\n\n    if (type !== BodyType.static) {\n        dynamicBodiesUuids.push(uuid)\n        syncBodies()\n    }\n\n    if (!body) {\n        throw new Error(`No body`)\n    }\n\n    existingBodies.set(uuid, body)\n\n    return body\n\n}\n\nexport type RemoveBodyProps = {\n    uuid: ValidUUID,\n    cacheKey?: string\n}\n\nconst tempVec = Vec2(0, 0)\n\nexport const removeBody = ({uuid, cacheKey}: RemoveBodyProps) => {\n    const index = dynamicBodiesUuids.indexOf(uuid)\n    if (index > -1) {\n        dynamicBodiesUuids.splice(index, 1)\n        syncBodies()\n    }\n    const body = existingBodies.get(uuid)\n    if (!body) {\n        console.warn(`Body not found for ${uuid}`)\n        return\n    }\n    existingBodies.delete(uuid)\n    if (cacheKey) {\n        tempVec.set(-1000, -1000)\n        body.setPosition(tempVec)\n        tempVec.set(0, 0)\n        body.setLinearVelocity(tempVec)\n        body.setActive(false)\n        addCachedBody(cacheKey, body)\n    } else {\n        planckWorld.destroyBody(body)\n    }\n}\n\nexport type SetBodyProps = {\n    uuid: ValidUUID,\n    method: string,\n    methodParams: any[],\n}\n\nexport const setBody = ({uuid, method, methodParams}: SetBodyProps) => {\n    const body = existingBodies.get(uuid)\n    if (!body) {\n        console.warn(`Body not found for ${uuid}`)\n        return\n    }\n    switch (method) {\n        //case 'setAngle':\n        //    const [angle] = methodParams\n        //    body.setTransform(body.getPosition(), angle)\n        //    break;\n        case 'setLinearVelocity':\n            // console.log('methodParams', methodParams[0].x, methodParams[0].y);\n            (body as any)[method](...methodParams)\n            break;\n        default:\n            (body as any)[method](...methodParams)\n    }\n}\n\nexport type UpdateBodyData = {\n    fixtureUpdate?: {\n        groupIndex?: number,\n        categoryBits?: number,\n        maskBits?: number,\n    }\n}\n\nexport type UpdateBodyProps = {\n    uuid: ValidUUID,\n    data: UpdateBodyData,\n}\n\nexport const updateBody = ({uuid, data}: UpdateBodyProps) => {\n    const body = existingBodies.get(uuid)\n    if (!body) {\n        console.warn(`Body not found for ${uuid}`)\n        return\n    }\n    const {fixtureUpdate} = data\n    if (fixtureUpdate) {\n        const fixture = body.getFixtureList()\n        if (fixture) {\n            const {\n                groupIndex,\n                categoryBits,\n                maskBits\n            } = fixtureUpdate\n            if (\n                groupIndex !== undefined || categoryBits !== undefined || maskBits !== undefined\n            ) {\n                const originalGroupIndex = fixture.getFilterGroupIndex()\n                const originalCategoryBits = fixture.getFilterCategoryBits()\n                const originalMaskBits = fixture.getFilterMaskBits()\n                fixture.setFilterData({\n                    groupIndex: groupIndex !== undefined ? groupIndex : originalGroupIndex,\n                    categoryBits: categoryBits !== undefined ? categoryBits : originalCategoryBits,\n                    maskBits: maskBits !== undefined ? maskBits : originalMaskBits,\n                })\n            }\n        }\n    }\n}","import React, {\n  createContext,\n  MutableRefObject,\n  useContext,\n  useRef,\n  useState,\n} from 'react';\nimport { ValidUUID } from '../shared/types';\nimport { Body } from 'planck-js';\n\ntype BodiesMap = Map<ValidUUID, Body>;\ntype DynamicBodies = Set<ValidUUID>;\ntype CollisionListeners = Set<ValidUUID>;\n\ntype ContextState = {\n  bodies: BodiesMap;\n  dynamicBodies: DynamicBodies;\n  collisionListeners: CollisionListeners;\n  bodiesNeedSync: boolean;\n  setBodiesNeedSync: (bool: boolean) => void;\n  bodiesNeedSyncRef: MutableRefObject<boolean>;\n  logicBodiesNeedSyncRef: MutableRefObject<boolean>;\n};\n\nconst Context = createContext((null as unknown) as ContextState);\n\nexport const useWorldState = (): ContextState => {\n  return useContext(Context);\n};\n\nexport const WorldState: React.FC = ({ children }) => {\n  const [bodies] = useState<BodiesMap>(() => new Map());\n  const [dynamicBodies] = useState<DynamicBodies>(() => new Set());\n  const [collisionListeners] = useState<CollisionListeners>(() => new Set());\n  const [bodiesNeedSync, setBodiesNeedSync] = useState(false);\n  const bodiesNeedSyncRef = useRef(false);\n  const logicBodiesNeedSyncRef = useRef(false);\n\n  return (\n    <Context.Provider\n      value={{\n        bodies,\n        dynamicBodies,\n        collisionListeners,\n        bodiesNeedSync,\n        setBodiesNeedSync,\n        bodiesNeedSyncRef,\n        logicBodiesNeedSyncRef,\n      }}\n    >\n      {children}\n    </Context.Provider>\n  );\n};\n","import React, { useCallback, useEffect, useState } from 'react';\nimport { useAppContext, useWorld } from './appContext';\nimport { ValidUUID, WorkerMessageType } from '../shared/types';\nimport {\n  Body,\n  BodyDef,\n  Box,\n  Circle,\n  DistanceJoint,\n  FixtureOpt,\n  Joint,\n  RopeJoint,\n  Vec2,\n} from 'planck-js';\nimport {\n  AddBodyProps,\n  BodyShape,\n  BodyType,\n  BoxFixture,\n  CircleFixture,\n  RemoveBodyProps,\n  SetBodyProps,\n  UpdateBodyProps,\n} from '../planckjs/bodies';\nimport { Shape } from 'planck-js/lib/shape';\nimport { useWorldState } from './WorldState';\n\nconst tempVec = Vec2(0, 0);\n\nexport const useSubscribeToWorkerMessages = (\n  messageHandler: (event: MessageEvent) => void\n) => {\n  const { subscribe, logicSubscribe } = useAppContext();\n\n  useEffect(() => {\n    const unsubscribe = subscribe(messageHandler);\n\n    const unsubscribeLogic = logicSubscribe(messageHandler);\n\n    return () => {\n      unsubscribe();\n      unsubscribeLogic();\n    };\n  }, [subscribe, logicSubscribe, messageHandler]);\n};\n\ntype BodiesMap = Map<ValidUUID, Body>;\ntype CachedBodiesMap = Map<string, Body[]>;\n\nconst applyBodyConfigToExistingBody = (\n  body: Body,\n  data: AddBodyProps\n): Body => {\n  const {\n    uuid,\n    cacheKey,\n    listenForCollisions,\n    fixtures = [],\n    attachToRope = false,\n    ...props\n  } = data;\n\n  if (fixtures && fixtures.length > 0) {\n    let bodyFixture = body.getFixtureList();\n\n    fixtures.forEach((fixture, fixtureIndex) => {\n      let fixtureOptions = fixture.fixtureOptions;\n\n      fixtureOptions = {\n        userData: {\n          uuid,\n          fixtureIndex,\n          ...fixtureOptions?.userData,\n        },\n        ...fixtureOptions,\n      };\n\n      if (bodyFixture) {\n        if (fixtureOptions) {\n          bodyFixture.setUserData(fixtureOptions.userData);\n        }\n\n        bodyFixture = bodyFixture.getNext();\n      }\n    });\n  }\n\n  const { position, angle } = props;\n\n  if (position) {\n    body.setPosition(position);\n  }\n\n  if (angle) {\n    body.setAngle(angle);\n  }\n\n  body.setActive(true);\n\n  return body;\n};\n\nconst useAddBody = (bodies: BodiesMap, cachedBodies: CachedBodiesMap) => {\n  const {\n    dynamicBodies,\n    collisionListeners,\n    bodiesNeedSyncRef,\n    logicBodiesNeedSyncRef,\n  } = useWorldState();\n\n  const addDynamicBody = useCallback(\n    (uuid: ValidUUID) => {\n      dynamicBodies.add(uuid);\n      bodiesNeedSyncRef.current = true;\n      logicBodiesNeedSyncRef.current = true;\n    },\n    [dynamicBodies, bodiesNeedSyncRef, logicBodiesNeedSyncRef]\n  );\n\n  const addCollisionListeners = useCallback(\n    (uuid: ValidUUID) => {\n      collisionListeners.add(uuid);\n    },\n    [collisionListeners]\n  );\n\n  const world = useWorld();\n\n  const getCachedBody = useCallback(\n    (cacheKey: string) => {\n      const cached = cachedBodies.get(cacheKey);\n\n      if (cached && cached.length > 0) {\n        const body = cached.pop();\n        if (body) {\n          return body;\n        }\n      }\n\n      return null;\n    },\n    [cachedBodies]\n  );\n\n  return useCallback(\n    (data: AddBodyProps) => {\n      const {\n        uuid,\n        cacheKey,\n        listenForCollisions,\n        fixtures = [],\n        attachToRope = false,\n        ...props\n      } = data;\n\n      const existingBody = bodies.get(uuid);\n\n      if (existingBody) {\n        return existingBody;\n      }\n\n      if (listenForCollisions) {\n        addCollisionListeners(uuid);\n      }\n\n      const bodyDef: BodyDef = {\n        type: BodyType.static,\n        fixedRotation: true,\n        ...props,\n      };\n\n      const { type } = bodyDef;\n\n      let body: Body | null = null;\n\n      if (cacheKey) {\n        let cachedBody = getCachedBody(cacheKey);\n\n        if (cachedBody) {\n          body = applyBodyConfigToExistingBody(cachedBody, data);\n        }\n      }\n\n      if (!body) {\n        body = world.createBody(bodyDef);\n\n        if (fixtures && fixtures.length > 0) {\n          fixtures.forEach((fixture, fixtureIndex) => {\n            const { shape } = fixture;\n\n            let fixtureOptions = fixture.fixtureOptions ?? {};\n\n            fixtureOptions = {\n              ...fixtureOptions,\n              userData: {\n                uuid,\n                fixtureIndex,\n                ...fixtureOptions?.userData,\n              },\n            };\n\n            let bodyShape: Shape;\n\n            switch (shape) {\n              case BodyShape.box:\n                const { hx, hy, center } = fixture as BoxFixture;\n                bodyShape = (Box(\n                  (hx as number) / 2,\n                  (hy as number) / 2,\n                  center ? Vec2(center[0], center[1]) : undefined\n                ) as unknown) as Shape;\n                break;\n              case BodyShape.circle:\n                const { radius } = fixture as CircleFixture;\n                bodyShape = (Circle(radius as number) as unknown) as Shape;\n                break;\n              default:\n                throw new Error(`Unhandled body shape ${shape}`);\n            }\n\n            if (fixtureOptions) {\n              if (body) {\n                body.createFixture(bodyShape, fixtureOptions as FixtureOpt);\n              }\n            } else {\n              if (body) {\n                body.createFixture(bodyShape);\n              }\n            }\n\n            // todo - handle rope properly...\n            if (attachToRope) {\n              const { position, angle } = props;\n\n              const ropeJointDef = {\n                maxLength: 0.5,\n                localAnchorA: position,\n                localAnchorB: position,\n              };\n\n              const startingBodyDef: BodyDef = {\n                type: BodyType.static,\n                fixedRotation: true,\n                position,\n                angle,\n              };\n\n              const startingBody = world.createBody(startingBodyDef);\n\n              if (body) {\n                const distanceJoint = DistanceJoint(\n                  {\n                    collideConnected: false,\n                    frequencyHz: 5,\n                    dampingRatio: 0.5,\n                    length: 0.15,\n                  },\n                  startingBody,\n                  body,\n                  position ?? Vec2(0, 0),\n                  position ?? Vec2(0, 0)\n                );\n\n                const rope2 = world.createJoint(\n                  (RopeJoint(\n                    ropeJointDef,\n                    startingBody,\n                    body,\n                    position ?? Vec2(0, 0)\n                  ) as unknown) as Joint\n                );\n                const rope = world.createJoint(\n                  (distanceJoint as unknown) as Joint\n                );\n              }\n            }\n          });\n        }\n      }\n\n      if (type !== BodyType.static) {\n        addDynamicBody(uuid);\n      }\n\n      if (!body) {\n        throw new Error(`No body`);\n      }\n\n      bodies.set(uuid, body);\n\n      return body;\n    },\n    [world, bodies, getCachedBody, addDynamicBody, addCollisionListeners]\n  );\n};\n\nconst useRemoveBody = (bodies: BodiesMap, cachedBodies: CachedBodiesMap) => {\n  const world = useWorld();\n  const {\n    dynamicBodies,\n    collisionListeners,\n    bodiesNeedSyncRef,\n    logicBodiesNeedSyncRef,\n  } = useWorldState();\n\n  return useCallback(\n    ({ uuid, cacheKey }: RemoveBodyProps) => {\n      if (dynamicBodies.has(uuid)) {\n        dynamicBodies.delete(uuid);\n        bodiesNeedSyncRef.current = true;\n        logicBodiesNeedSyncRef.current = true;\n      }\n\n      collisionListeners.delete(uuid);\n\n      const body = bodies.get(uuid);\n\n      if (!body) {\n        console.warn(`Body not found for ${uuid}`);\n        return;\n      }\n\n      bodies.delete(uuid);\n\n      if (cacheKey) {\n        tempVec.set(-1000, -1000);\n        body.setPosition(tempVec);\n        tempVec.set(0, 0);\n        body.setLinearVelocity(tempVec);\n        body.setActive(false);\n        const cached = cachedBodies.get(cacheKey);\n        if (cached) {\n          cached.push(body);\n        } else {\n          cachedBodies.set(cacheKey, [body]);\n        }\n      } else {\n        world.destroyBody(body);\n      }\n    },\n    [\n      world,\n      bodies,\n      dynamicBodies,\n      collisionListeners,\n      bodiesNeedSyncRef,\n      logicBodiesNeedSyncRef,\n      cachedBodies,\n    ]\n  );\n};\n\nconst useSetBody = (bodies: BodiesMap) => {\n  return useCallback(\n    ({ uuid, method, methodParams }: SetBodyProps) => {\n      const body = bodies.get(uuid);\n      if (!body) {\n        console.warn(`Body not found for ${uuid}`, bodies);\n        return;\n      }\n      switch (method) {\n        default:\n          (body as any)[method](...methodParams);\n      }\n    },\n    [bodies]\n  );\n};\n\nconst useUpdateBody = (bodies: BodiesMap) => {\n  return useCallback(\n    ({ uuid, data }: UpdateBodyProps) => {\n      const body = bodies.get(uuid);\n      if (!body) {\n        console.warn(`Body not found for ${uuid}`);\n        return;\n      }\n      const { fixtureUpdate } = data;\n      if (fixtureUpdate) {\n        const fixture = body.getFixtureList();\n        if (fixture) {\n          const { groupIndex, categoryBits, maskBits } = fixtureUpdate;\n          if (\n            groupIndex !== undefined ||\n            categoryBits !== undefined ||\n            maskBits !== undefined\n          ) {\n            const originalGroupIndex = fixture.getFilterGroupIndex();\n            const originalCategoryBits = fixture.getFilterCategoryBits();\n            const originalMaskBits = fixture.getFilterMaskBits();\n            fixture.setFilterData({\n              groupIndex:\n                groupIndex !== undefined ? groupIndex : originalGroupIndex,\n              categoryBits:\n                categoryBits !== undefined\n                  ? categoryBits\n                  : originalCategoryBits,\n              maskBits: maskBits !== undefined ? maskBits : originalMaskBits,\n            });\n          }\n        }\n      }\n    },\n    [bodies]\n  );\n};\n\nexport const Bodies: React.FC = () => {\n  const { bodies } = useWorldState();\n  const [cachedBodies] = useState<CachedBodiesMap>(() => new Map());\n\n  const addBody = useAddBody(bodies, cachedBodies);\n  const removeBody = useRemoveBody(bodies, cachedBodies);\n  const setBody = useSetBody(bodies);\n  const updateBody = useUpdateBody(bodies);\n\n  const onMessage = useCallback(\n    (event: MessageEvent) => {\n      const { type, props = {} } = event.data as {\n        type: WorkerMessageType;\n        props: any;\n      };\n      switch (type) {\n        case WorkerMessageType.ADD_BODY:\n          addBody(props);\n          break;\n        case WorkerMessageType.REMOVE_BODY:\n          removeBody(props);\n          break;\n        case WorkerMessageType.SET_BODY:\n          setBody(props);\n          break;\n        case WorkerMessageType.UPDATE_BODY:\n          updateBody(props);\n          break;\n      }\n    },\n    [addBody, removeBody, setBody, updateBody]\n  );\n\n  useSubscribeToWorkerMessages(onMessage);\n\n  return null;\n};\n","import React, { MutableRefObject, useCallback, useEffect, useRef } from 'react';\nimport { useAppContext, useWorld } from './appContext';\nimport {\n  Buffers,\n  WorkerMessageType,\n  WorkerOwnerMessageType,\n} from '../shared/types';\nimport { useWorldState } from './WorldState';\n\nconst useSyncData = () => {\n  const { dynamicBodies, bodies } = useWorldState();\n  return useCallback((positions: Float32Array, angles: Float32Array) => {\n    const dynamicBodiesArray = Array.from(dynamicBodies);\n\n    dynamicBodiesArray.forEach((uuid, index) => {\n      const body = bodies.get(uuid);\n      if (!body) return;\n      const position = body.getPosition();\n      const angle = body.getAngle();\n      positions[2 * index + 0] = position.x;\n      positions[2 * index + 1] = position.y;\n      angles[index] = angle;\n    });\n  }, []);\n};\n\nconst useSendPhysicsUpdate = (tickRef: MutableRefObject<number>) => {\n  const {\n    bodiesNeedSyncRef,\n    logicBodiesNeedSyncRef,\n    dynamicBodies,\n  } = useWorldState();\n\n  const syncData = useSyncData();\n\n  return useCallback(\n    (target: Worker | MessagePort, buffer: Buffers, isMain: boolean) => {\n      const { positions, angles } = buffer;\n      if (!(positions.byteLength !== 0 && angles.byteLength !== 0)) {\n        return;\n      }\n      syncData(positions, angles);\n      const rawMessage: any = {\n        type: WorkerOwnerMessageType.PHYSICS_STEP,\n        physicsTick: tickRef.current,\n      };\n      if (isMain) {\n        rawMessage.bodies = Array.from(dynamicBodies);\n        bodiesNeedSyncRef.current = false;\n      } else {\n        rawMessage.bodies = Array.from(dynamicBodies);\n        logicBodiesNeedSyncRef.current = false;\n      }\n      const message = {\n        ...rawMessage,\n        positions,\n        angles,\n      };\n      target.postMessage(message, [positions.buffer, angles.buffer]);\n    },\n    [bodiesNeedSyncRef, logicBodiesNeedSyncRef, tickRef, syncData]\n  );\n};\n\nconst useSendPhysicsUpdates = (tickRef: MutableRefObject<number>) => {\n  const {\n    buffers: mainBuffers,\n    logicBuffers,\n    worker,\n    logicWorker,\n  } = useAppContext();\n\n  const sendPhysicsUpdate = useSendPhysicsUpdate(tickRef);\n\n  const update = useCallback(() => {\n    sendPhysicsUpdate(worker, mainBuffers, true);\n\n    if (logicWorker) {\n      sendPhysicsUpdate(logicWorker, logicBuffers, false);\n    }\n  }, [worker, logicWorker, sendPhysicsUpdate, mainBuffers, logicBuffers]);\n\n  const updateRef = useRef(update);\n\n  useEffect(() => {\n    updateRef.current = update;\n  }, [update, updateRef]);\n\n  return useCallback(() => {\n    // using ref, as i don't want to interrupt the interval\n    updateRef.current();\n  }, [updateRef]);\n};\n\nconst useStepProcessed = (tickRef: MutableRefObject<number>) => {\n  const {\n    buffers: mainBuffers,\n    logicBuffers,\n    worker,\n    logicWorker,\n  } = useAppContext();\n\n  const sendPhysicsUpdate = useSendPhysicsUpdate(tickRef);\n\n  return useCallback(\n    (\n      isMain: boolean,\n      lastProcessedPhysicsTick: number,\n      positions: Float32Array,\n      angles: Float32Array\n    ) => {\n      const buffers = isMain ? mainBuffers : logicBuffers;\n\n      buffers.positions = positions;\n      buffers.angles = angles;\n      if (lastProcessedPhysicsTick < tickRef.current) {\n        if (isMain) {\n          sendPhysicsUpdate(worker, buffers, true);\n        } else if (logicWorker) {\n          sendPhysicsUpdate(logicWorker, buffers, false);\n        }\n      }\n    },\n    [mainBuffers, logicBuffers, tickRef, worker, logicWorker, sendPhysicsUpdate]\n  );\n};\n\nconst useWorldLoop = () => {\n  const world = useWorld();\n  const { updateRate, subscribe, logicSubscribe } = useAppContext();\n  const tickRef = useRef(0);\n\n  const sendPhysicsUpdate = useSendPhysicsUpdates(tickRef);\n\n  useEffect(() => {\n    const step = () => {\n      world.step(updateRate);\n    };\n\n    const interval = setInterval(() => {\n      tickRef.current += 1;\n      step();\n      sendPhysicsUpdate();\n    }, updateRate);\n\n    return () => {\n      clearInterval(interval);\n    };\n  }, []);\n\n  const stepProcessed = useStepProcessed(tickRef);\n\n  useEffect(() => {\n    const onMessage = (event: MessageEvent, isMain: boolean = true) => {\n      const { type, props = {} } = event.data as {\n        type: WorkerMessageType;\n        props: any;\n      };\n      if (type === WorkerMessageType.PHYSICS_STEP_PROCESSED) {\n        stepProcessed(\n          isMain,\n          event.data.physicsTick,\n          event.data.positions,\n          event.data.angles\n        );\n      }\n    };\n\n    const unsubscribe = subscribe(onMessage);\n\n    const unsubscribeLogic = logicSubscribe(event => onMessage(event, false));\n\n    return () => {\n      unsubscribe();\n      unsubscribeLogic();\n    };\n  }, [subscribe, logicSubscribe, stepProcessed]);\n};\n\nexport const World: React.FC = () => {\n  useWorldLoop();\n  return null;\n};\n","import React, { useCallback, useEffect } from 'react';\nimport { useAppContext, useWorld } from './appContext';\nimport { Contact, Fixture } from 'planck-js';\nimport {\n  getFixtureData,\n  getFixtureIndex,\n  getFixtureUuid,\n} from '../planckjs/collisions/collisions';\nimport { useWorldState } from './WorldState';\nimport { WorkerOwnerMessageType } from '../shared/types';\n\nconst useHandleBeginCollision = () => {\n  const { worker, logicWorker } = useAppContext();\n  const { collisionListeners } = useWorldState();\n  const sendCollisionBeginEvent = useCallback(\n    (uuid: string, data: any, fixtureIndex: number, isSensor: boolean) => {\n      const update = {\n        type: WorkerOwnerMessageType.BEGIN_COLLISION,\n        props: {\n          uuid,\n          data,\n          fixtureIndex,\n          isSensor,\n        },\n      };\n      worker.postMessage(update);\n      if (logicWorker) {\n        logicWorker.postMessage(update);\n      }\n    },\n    [worker, logicWorker]\n  );\n\n  return useCallback(\n    (fixtureA: Fixture, fixtureB: Fixture) => {\n      const aData = getFixtureData(fixtureA);\n      const bData = getFixtureData(fixtureB);\n      const aUUID = getFixtureUuid(aData);\n      const bUUID = getFixtureUuid(bData);\n\n      if (aUUID && collisionListeners.has(aUUID)) {\n        sendCollisionBeginEvent(\n          aUUID,\n          bData,\n          getFixtureIndex(aData),\n          fixtureB.isSensor()\n        );\n      }\n\n      if (bUUID && collisionListeners.has(bUUID)) {\n        sendCollisionBeginEvent(\n          bUUID,\n          aData,\n          getFixtureIndex(bData),\n          fixtureA.isSensor()\n        );\n      }\n    },\n    [collisionListeners, sendCollisionBeginEvent]\n  );\n};\n\nconst useHandleEndCollision = () => {\n  const { worker, logicWorker } = useAppContext();\n  const { collisionListeners } = useWorldState();\n\n  const sendCollisionEndEvent = useCallback(\n    (uuid: string, data: any, fixtureIndex: number, isSensor: boolean) => {\n      const update = {\n        type: WorkerOwnerMessageType.END_COLLISION,\n        props: {\n          uuid,\n          data,\n          fixtureIndex,\n          isSensor,\n        },\n      };\n      worker.postMessage(update);\n      if (logicWorker) {\n        logicWorker.postMessage(update);\n      }\n    },\n    [worker, logicWorker]\n  );\n\n  return useCallback(\n    (fixtureA: Fixture, fixtureB: Fixture) => {\n      const aData = getFixtureData(fixtureA);\n      const bData = getFixtureData(fixtureB);\n      const aUUID = getFixtureUuid(aData);\n      const bUUID = getFixtureUuid(bData);\n\n      if (aUUID && collisionListeners.has(aUUID)) {\n        sendCollisionEndEvent(\n          aUUID,\n          bData,\n          getFixtureIndex(aData),\n          fixtureB.isSensor()\n        );\n      }\n\n      if (bUUID && collisionListeners.has(bUUID)) {\n        sendCollisionEndEvent(\n          bUUID,\n          aData,\n          getFixtureIndex(bData),\n          fixtureA.isSensor()\n        );\n      }\n    },\n    [collisionListeners, sendCollisionEndEvent]\n  );\n};\n\nexport const Collisions: React.FC = () => {\n  const world = useWorld();\n\n  const handleBeginCollision = useHandleBeginCollision();\n  const handleEndCollision = useHandleEndCollision();\n\n  useEffect(() => {\n    world.on('begin-contact', (contact: Contact) => {\n      const fixtureA = contact.getFixtureA();\n      const fixtureB = contact.getFixtureB();\n      handleBeginCollision(fixtureA, fixtureB);\n    });\n\n    world.on('end-contact', (contact: Contact) => {\n      const fixtureA = contact.getFixtureA();\n      const fixtureB = contact.getFixtureB();\n      handleEndCollision(fixtureA, fixtureB);\n    });\n  }, [world]);\n\n  return null;\n};\n","import { useEffect, useState } from 'react';\nimport { Buffers } from '../shared/types';\n\nexport const useBuffers = (maxNumberOfDynamicObjects: number): Buffers => {\n  const [buffers] = useState(() => ({\n    positions: new Float32Array(maxNumberOfDynamicObjects * 2),\n    angles: new Float32Array(maxNumberOfDynamicObjects),\n  }));\n\n  useEffect(() => {\n    buffers.positions = new Float32Array(maxNumberOfDynamicObjects * 2);\n    buffers.angles = new Float32Array(maxNumberOfDynamicObjects);\n  }, [maxNumberOfDynamicObjects]);\n\n  return buffers;\n};\n","import React, { useEffect, useState } from 'react';\nimport { Vec2, World, WorldDef } from 'planck-js';\nimport { AppContext } from './appContext';\nimport { useWorkerMessages } from '../../hooks/useWorkerMessages';\nimport { Bodies } from './Bodies';\nimport { World as WorldComponent } from './World';\nimport { useSubscribeLogicWorker, useLogicWorker } from './logicWorker';\nimport { WorldState } from './WorldState';\nimport { Collisions } from './Collisions';\nimport { WorkerOwnerMessageType } from '../shared/types';\nimport { useBuffers } from './buffers';\n\nexport const App: React.FC<{\n  config: {\n    maxNumberOfDynamicObjects: number;\n    updateRate: number;\n  };\n  worldParams: WorldDef;\n  worker: Worker;\n}> = ({ worldParams, worker, config }) => {\n  const { updateRate, maxNumberOfDynamicObjects } = config;\n\n  const defaultParams = {\n    allowSleep: true,\n    gravity: Vec2(0, 0),\n    ...worldParams,\n  };\n\n  const [world] = useState(() => World(defaultParams));\n\n  const subscribe = useWorkerMessages(worker);\n\n  const logicWorker = useLogicWorker(worker, subscribe);\n\n  const logicSubscribe = useSubscribeLogicWorker(logicWorker);\n\n  const buffers = useBuffers(maxNumberOfDynamicObjects);\n  const logicBuffers = useBuffers(!logicWorker ? maxNumberOfDynamicObjects : 0);\n\n  useEffect(() => {\n    worker.postMessage({\n      type: WorkerOwnerMessageType.INITIATED,\n    });\n  }, [worker]);\n\n  return (\n    <AppContext.Provider\n      value={{\n        world,\n        updateRate,\n        worker,\n        logicWorker,\n        subscribe,\n        logicSubscribe,\n        buffers,\n        logicBuffers,\n      }}\n    >\n      <WorldState>\n        <WorldComponent />\n        <Bodies />\n        <Collisions />\n      </WorldState>\n    </AppContext.Provider>\n  );\n};\n","import { Subscribe, useWorkerMessages } from '../../hooks/useWorkerMessages';\nimport { useEffect, useState } from 'react';\n\nexport const useSubscribeLogicWorker = (\n  worker: Worker | MessagePort | undefined\n) => {\n  const subscribe = useWorkerMessages(worker);\n  return subscribe;\n};\n\nexport const useLogicWorker = (\n  worker: Worker,\n  subscribe: Subscribe\n): undefined | Worker | MessagePort => {\n  const [logicWorker, setLogicWorker] = useState<MessagePort>();\n\n  useEffect(() => {\n    let logicWorkerPort: MessagePort;\n\n    const handleMessage = (event: MessageEvent) => {\n      if (event.data.command === 'connect') {\n        logicWorkerPort = event.ports[0];\n        setLogicWorker(logicWorkerPort);\n        return;\n      } else if (event.data.command === 'forward') {\n        logicWorkerPort.postMessage(event.data.message);\n        return;\n      }\n    };\n\n    const unsubscribe = subscribe(event => {\n      if (event.data.command) {\n        handleMessage(event);\n      }\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, [worker, subscribe, setLogicWorker]);\n\n  return logicWorker;\n};\n"],"names":["WorkerMessageType","WorkerOwnerMessageType","AppContext","createContext","useWorld","useContext","world","useAppContext","useWorkerMessages","worker","idCount","useRef","subscriptionsRef","subscribe","useCallback","callback","id","current","useEffect","previousOnMessage","onmessage","event","Object","values","forEach","BodyType","BodyShape","getFixtureData","fixture","getUserData","getFixtureUuid","data","uuid","getFixtureIndex","fixtureIndex","Context","useWorldState","WorldState","children","bodies","useState","Map","dynamicBodies","Set","collisionListeners","bodiesNeedSync","setBodiesNeedSync","bodiesNeedSyncRef","logicBodiesNeedSyncRef","React","Provider","value","tempVec","Vec2","Bodies","messageHandler","logicSubscribe","cachedBodies","addBody","addDynamicBody","add","addCollisionListeners","getCachedBody","cacheKey","cached","get","length","body","pop","listenForCollisions","fixtures","attachToRope","props","existingBody","bodyDef","type","fixedRotation","cachedBody","bodyFixture","getFixtureList","fixtureOptions","userData","_fixtureOptions","setUserData","getNext","position","angle","setPosition","setAngle","setActive","applyBodyConfigToExistingBody","createBody","bodyShape","shape","_fixtureOptions2","box","center","Box","hx","hy","undefined","circle","Circle","radius","Error","createFixture","ropeJointDef","maxLength","localAnchorA","localAnchorB","startingBody","distanceJoint","DistanceJoint","collideConnected","frequencyHz","dampingRatio","createJoint","RopeJoint","set","useAddBody","removeBody","has","setLinearVelocity","push","destroyBody","console","warn","useRemoveBody","setBody","method","methodParams","useSetBody","updateBody","fixtureUpdate","groupIndex","categoryBits","maskBits","originalGroupIndex","getFilterGroupIndex","originalCategoryBits","getFilterCategoryBits","originalMaskBits","getFilterMaskBits","setFilterData","useUpdateBody","onMessage","ADD_BODY","REMOVE_BODY","SET_BODY","UPDATE_BODY","unsubscribe","unsubscribeLogic","useSendPhysicsUpdate","tickRef","syncData","positions","angles","Array","from","index","getPosition","getAngle","x","y","useSyncData","target","buffer","isMain","byteLength","rawMessage","PHYSICS_STEP","physicsTick","message","postMessage","World","updateRate","sendPhysicsUpdate","mainBuffers","buffers","logicBuffers","logicWorker","update","updateRef","useSendPhysicsUpdates","interval","setInterval","step","clearInterval","stepProcessed","lastProcessedPhysicsTick","useStepProcessed","PHYSICS_STEP_PROCESSED","useWorldLoop","Collisions","sendCollisionBeginEvent","handleBeginCollision","isSensor","BEGIN_COLLISION","fixtureA","fixtureB","aData","bData","aUUID","bUUID","handleEndCollision","sendCollisionEndEvent","END_COLLISION","useHandleEndCollision","on","contact","getFixtureA","getFixtureB","useBuffers","maxNumberOfDynamicObjects","Float32Array","worldParams","config","defaultParams","allowSleep","gravity","setLogicWorker","logicWorkerPort","command","ports","handleMessage","useLogicWorker","useSubscribeLogicWorker","INITIATED","WorldComponent"],"mappings":"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"}